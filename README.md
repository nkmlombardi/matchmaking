# Matchmaking Service
The matchmaking service has three main components. The `MatchmakingService`, `MatchService`, and `QueueService`, all of which are responsible for different functionality. The `QueueService` is the storage for players looking for a match. In retrospect, although it is named Queue, something like "Pool" would be more appropriate.

The `MatchmakingService` acts upon the `QueueService` by iterating through the player pool, searching for players that can be matched up. It keeps track of how many attempts the service has made to match a player, and increases the breadth of the search each pass. Upon matching, the `MatchService` is called, to create a match between the players, and they are removed from the `QueueService` pool.

The breadth of the search is increased on a logarithmic scale, maxing out to a system defined number of iterations. This places a maximum queue time for a player. If the tick rate for searching is 1 second, and there is a max of 60 iterations, then max queue time is 60 seconds. The logarithmic scale can be swapped out for quadtratic, linear or any other type of scale by replacing the logic in the `calculateRange` method.

For testing purposes, the `startIterative` method was created so the results could be tested in a synchronous, and immediate way. This method uses no delays, and executes all logic immediately.

## Scalability
This system would scale by implementing a keystore database (Redis) for storing queued players. This system would reach further scalability by sharding this keystore by MMR. Players would be placed in buckets, sorted by MMR. There would be a process running for each shard, searching for matches within the bucket, this would allow for parallel processing across the MMR range, and keeping the system from being single-threaded. If a player can't be matched within it's shard for a certain period of time, then it searches the shards around it for a match. This however, could create a race condition as the player could be matched in two shards at once. To alleviate this issue, a lock system could be put in place, where one matchmaking process can't attempt to match a player if another process is currently accessing the data. The size and number of the Redis / MMR shards could be fine tuned to match the distribution of players across the MMR spectrum to achieve maximum efficiency. In other words, there should be more, smaller shards in the middle area (2000-2500), than at the top of the MMR range (4000).
